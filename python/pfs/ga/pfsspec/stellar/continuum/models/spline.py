import numpy as np
from scipy.interpolate import splrep, splev

from .continuummodel import ContinuumModel

class Spline(ContinuumModel):
    def __init__(self, degrees=None, control_points=None, continuum_finder=None, trace=None, orig=None):    
        super().__init__(continuum_finder=continuum_finder,
                         trace=trace, orig=orig)
        
        if not isinstance(orig, Spline):
            self.degrees = degrees if degrees is not None else 3                            # Degree of the spline.
            self.control_points = control_points if control_points is not None else 25      # Number of control points.

            self.wave_sort = None
        else:
            self.degrees = degrees if degrees is not None else orig.degrees
            self.control_points = control_points if control_points is not None else orig.control_points

            self.wave_sort = orig.wave_sort

        self.version = 1

    @property
    def name(self):
        return 'spline'
    
    def add_args(self, parser):
        super().add_args(parser)

        # TODO

    def init_from_args(self, args):
        super().init_from_args(args)

        # TODO
        
    def get_constants(self, wave=None):
        """
        Return the constants necessary to evaluate the continuum model
        """

        constants = super().get_constants(wave=wave)
        constants.update({
            f'{self.name}_degrees': np.array(self.degrees),
        })

        return constants
    
    def set_constants(self, constants, wave=None):
        """
        Load the constants necessary to evaluate the continuum model
        """

        super().set_constants(constants, wave=wave)

        if self.version == 1:
            self.degrees = constants[f'{self.name}_degrees']

    def init_wave(self, wave, force=True, omit_overflow=False):
        super().init_wave(wave, force=force, omit_overflow=omit_overflow)

        # The function `splrep` requires the input to be in order, so sort by wave
        if self.wave_sort is None or force:
            self.wave_sort = np.argsort(self.wave)
        
    def fit_impl(self, flux, flux_err, mask, continuum_finder):
        """
        Fit the function to the pixels.

        Parameters
        ----------
        flux : array
            The flux values.
        flux_err : array
            The flux errors.
        spectrum_mask : array
            The mask for the spectrum.
        continuum_mask : array
            The mask for the continuum, generated by the continuum finder.
        """

        if continuum_finder is not None:
            raise NotImplementedError()
        
        # We sort by wavelength, in case there are multiple exposures contacenated
        wave = self.wave
        s = self.wave_sort
        
        # Create a list of control points
        mask = mask[s]
        size = mask.sum()
        knots = np.round(np.linspace(0, size - 1, self.control_points)).astype(int)[1:-1]
        w = 1 / flux_err[s][mask] ** 2 if flux_err is not None else None
        t, c, k = splrep(wave[s][mask], flux[s][mask], w=w, t=wave[s][mask][knots], k=self.degrees)

        return {
            f'{self.name}_t': t,
            f'{self.name}_c': c
        }

    def eval_impl(self, params, wave=None):
        """
        Evaluate the function.
        """

        wave = wave if wave is not None else self.wave

        t = params[f'{self.name}_t']
        c = params[f'{self.name}_c']

        spline = (t, c, self.degrees)
        model = splev(wave, spline)
        mask = (t[0] <= wave) & (wave <= t[-1])
        return model, mask
