import numpy as np
from scipy.interpolate import splrep, splev

from .continuummodel import ContinuumModel

class Spline(ContinuumModel):
    def __init__(self, deg=None, npix=None, continuum_finder=None, trace=None, orig=None):    
        super().__init__(continuum_finder=continuum_finder,
                         trace=trace, orig=orig)
        
        if not isinstance(orig, Spline):
            self.deg = deg if deg is not None else 3                  # Degree of the spline.
            self.npix = npix if npix is not None else 200             # Minimum separation of knots in spectra pixels.

            self.wave_sort = None
        else:
            self.deg = deg if deg is not None else orig.deg
            self.npix = npix if npix is not None else orig.npix

            self.wave_sort = orig.wave_sort

        self.version = 1

    @property
    def name(self):
        return 'spline'
    
    def add_args(self, parser):
        super().add_args(parser)

        # TODO

    def init_from_args(self, args):
        super().init_from_args(args)

        # TODO
        
    def get_constants(self, wave=None):
        """
        Return the constants necessary to evaluate the continuum model
        """

        constants = super().get_constants(wave=wave)
        constants.update({
            f'{self.name}_deg': np.array(self.deg),
        })

        return constants
    
    def set_constants(self, constants, wave=None):
        """
        Load the constants necessary to evaluate the continuum model
        """

        super().set_constants(constants, wave=wave)

        if self.version == 1:
            self.deg = constants[f'{self.name}_deg']

    def init_wave(self, wave, force=True, omit_overflow=False):
        super().init_wave(wave, force=force, omit_overflow=omit_overflow)

        # The function `splrep` requires the input to be in order, so sort by wave
        if self.wave_sort is None or force:
            self.wave_sort = np.argsort(self.wave)
        
    def fit_impl(self, flux, flux_err, mask, continuum_finder):
        """
        Fit the function to the pixels.

        Parameters
        ----------
        flux : array
            The flux values.
        flux_err : array
            The flux errors.
        spectrum_mask : array
            The mask for the spectrum.
        continuum_mask : array
            The mask for the continuum, generated by the continuum finder.
        """

        if continuum_finder is not None:
            raise NotImplementedError()
        
        wave = self.wave
        s = self.wave_sort
        
        mask = self.get_full_mask(mask)[s]
        knots = np.round(np.linspace(0, wave[mask].size, int(wave[mask].size / self.npix)))[1:-1].astype(int)
        w = 1 / flux_err[s][mask] ** 2 if flux_err is not None else None
        t, c, k = splrep(wave[s][mask], flux[s][mask], w=w, t=wave[s][mask][knots], k=self.deg)

        return {
            f'{self.name}_t': t,
            f'{self.name}_c': c
        }

    def eval_impl(self, params, wave=None):
        """
        Evaluate the function.
        """

        wave = wave if wave is not None else self.wave

        t = params[f'{self.name}_t']
        c = params[f'{self.name}_c']

        spline = (t, c, self.deg)
        model = splev(wave, spline)
        return model
